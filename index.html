<!doctype html>
<html lang="vi">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Công cụ nhanh — Phân tích ĐƠN CAM / LU</title>
<style>
  :root{
    --bg:#0f1724; --card:#071428; --muted:#9fb0c4; --accent:#ff8a4b; --ok:#38d39f; --bad:#ff6b6b;
  }
  body{font-family:Inter,system-ui,Segoe UI,Roboto,Arial; margin:18px; background:linear-gradient(180deg,#041025,#08162a); color:#e6f0f6;}
  .wrap{max-width:1100px;margin:0 auto;}
  h1{margin:0 0 6px 0;font-size:20px}
  p.lead{margin:4px 0 18px;color:var(--muted);font-size:13px}
  .panel{display:flex;gap:12px;flex-wrap:wrap;margin-bottom:12px}
  .card{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); border-radius:10px; padding:12px; box-shadow:0 6px 30px rgba(0,0,0,0.6); flex:1; min-width:260px}
  label{display:block;color:var(--muted);font-size:13px;margin-bottom:6px}
  input[type="number"], select{width:100%;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:#e6eef6}
  .controls{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
  button{border:0;padding:8px 10px;border-radius:8px;background:var(--accent);color:#08121a;cursor:pointer;font-weight:700}
  button.ghost{background:transparent;color:var(--muted);border:1px solid rgba(255,255,255,0.04)}
  .gridWrap{background:rgba(255,255,255,0.02);padding:10px;border-radius:8px;margin-top:10px;overflow:auto}
  .gridHeader{display:grid;gap:6px;margin-bottom:6px}
  .row{display:grid;grid-auto-flow:column;gap:6px;margin-bottom:6px}
  .cellBtn{min-width:44px;min-height:36px;border-radius:6px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:#e8f6ff;font-weight:700;cursor:pointer}
  .cellBtn.sel{outline:3px solid rgba(56,211,159,0.18)}
  .palette{display:flex;gap:6px;align-items:center;flex-wrap:wrap}
  .symBtn{padding:6px 10px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:rgba(255,255,255,0.02);color:#e6f0f6;cursor:pointer}
  table{width:100%;border-collapse:collapse;margin-top:12px}
  th,td{padding:8px;border-bottom:1px solid rgba(255,255,255,0.03);text-align:left;font-size:14px}
  th{color:var(--muted);font-weight:700}
  .pos{color:var(--ok);font-weight:700}
  .neg{color:var(--bad);font-weight:700}
  .hint{font-size:13px;color:var(--muted);margin-top:8px}
  @media (max-width:900px){ .panel{flex-direction:column} }
</style>
</head>
<body>
  <div class="wrap">
    <h1>Công cụ tính — CAM / LU</h1>
    <p class="lead">cre: TRẠC THOÒNG</p>

    <div class="panel">
      <div class="card" style="flex:0 0 240px">
        <label>Tổng số CAM</label>
        <input id="totalCams" type="number" value="84" min="1" max="120" />
        <div class="hint">Ví dụ: 84 (mặc định). Hệ thống chia chu kỳ và xét phần dư nếu có.</div>



<div class="hint">‼️Cách dùng: bấm 1 hoặc nhiều ô để chọn (xanh), rồi bấm ký hiệu để gán. Double-click ô để đổi ký hiệu tuần tự.</div>
      </div>

      <div class="card">
        <label><strong>ĐƠN CŨ (LEFT)</strong></label>
        <div style="display:flex;gap:8px">
          <div style="flex:1">
            <label>Số cột (chu kỳ)</label>
            <input id="colsOld" type="number" value="4" min="1" />
          </div>
          <div style="flex:1">
            <label>Số hàng (LU)</label>
            <input id="rowsOld" type="number" value="2" min="1" />
          </div>
        </div>
        <div class="controls">
          <button id="genOld">Tạo lưới</button>
          <button class="ghost" id="clearOld">Xoá</button>
          <button class="ghost" id="fillOld">Mẫu ví dụ</button>
        </div>
        <div class="gridWrap" id="gridOldWrap"></div>
      </div>

      <div class="card">
        <label><strong>ĐƠN MỚI (RIGHT)</strong></label>
        <div style="display:flex;gap:8px">
          <div style="flex:1">
            <label>Số cột (chu kỳ)</label>
            <input id="colsNew" type="number" value="6" min="1" />
          </div>
          <div style="flex:1">
            <label>Số hàng (LU)</label>
            <input id="rowsNew" type="number" value="2" min="1" />
          </div>
        </div>
        <div class="controls">
          <button id="genNew">Tạo lưới</button>
          <button class="ghost" id="clearNew">Xoá</button>
          <button class="ghost" id="fillNew">Mẫu ví dụ</button>
        </div>
        <div class="gridWrap" id="gridNewWrap"></div>
      </div>
    </div>

    <div style="display:flex;gap:12px;align-items:center;margin-top:8px">
      <div style="flex:1">
        <div class="palette">
          <span class="small" style="color:var(--muted)">Bảng ký hiệu nhanh:</span>
          <button class="symBtn" data-sym="^">^</button>
          <button class="symBtn" data-sym="-">-</button>
          <button class="symBtn" data-sym="凵">凵</button>
          <button class="symBtn" data-sym="">Xóa</button>
        </div>
   
      </div>

      <div style="display:flex;gap:8px">
        <button id="compute" style="background:var(--ok);color:#021214">Tính & Bù trừ</button>
        <button id="exportCsv" class="ghost">Tải CSV</button>
        <button id="resetAll" class="ghost">Reset</button>
      </div>
    </div>

    <div id="resultArea"></div>
  </div>

<script>
/* ---------- Helpers & State ---------- */
const symbols = ['^','-','凵','']; // '' = clear
let selectedCells = new Set();
const state = {
  old: null,
  new: null
};

function q(sel){ return document.querySelector(sel); }
function qAll(sel){ return Array.from(document.querySelectorAll(sel)); }

/* ---------- Grid generation ---------- */
function createGrid(containerId, cols, rows, prefix){
  const container = q(containerId);
  container.innerHTML = '';
  // header row (col indexes)
  const header = document.createElement('div');
  header.className = 'gridHeader';
  header.style.gridTemplateColumns = `repeat(${cols}, minmax(44px, 1fr))`;
  header.style.display = 'grid';
  header.style.gap = '6px';
  for(let c=0;c<cols;c++){
    const hd = document.createElement('div');
    hd.className = 'cellBtn';
    hd.style.fontSize = '12px';
    hd.textContent = `c${c+1}`;
    hd.style.background='rgba(255,255,255,0.02)';
    header.appendChild(hd);
  }
  container.appendChild(header);
  // rows
  for(let r=0;r<rows;r++){
    const rowDiv = document.createElement('div');
    rowDiv.className = 'row';
    rowDiv.style.gridTemplateColumns = `repeat(${cols}, minmax(44px,1fr))`;
    for(let c=0;c<cols;c++){
      const btn = document.createElement('button');
      btn.className = 'cellBtn';
      btn.dataset.row = r;
      btn.dataset.col = c;
      btn.dataset.val = ''; // empty
      btn.textContent = '';
      btn.addEventListener('click', (e)=> {
        toggleSelect(btn);
      });
      btn.addEventListener('dblclick', (e)=> {
        cycleSymbol(btn);
      });
      // allow ctrl/shift selection
      btn.addEventListener('mousedown', (e)=> {
        if(e.shiftKey || e.ctrlKey || e.metaKey) {
          // handled by click toggleSelect
        }
      });
      rowDiv.appendChild(btn);
    }
    container.appendChild(rowDiv);
  }
  // save into state
  state[prefix] = {cols:cols, rows:rows, containerId:containerId};
}

function toggleSelect(btn){
  const key = getCellKey(btn);
  if(selectedCells.has(key)){
    selectedCells.delete(key);
    btn.classList.remove('sel');
  } else {
    selectedCells.add(key);
    btn.classList.add('sel');
  }
}
function clearSelection(){
  selectedCells.forEach(k=>{
    const el = document.querySelector(`[data-cellkey="${k}"]`);
    if(el) el.classList.remove('sel');
  });
  selectedCells = new Set();
}
function getCellKey(btn){
  return `${btn.parentElement.parentElement.id}::r${btn.dataset.row}c${btn.dataset.col}`;
}
function selectButtonElement(btn){
  // ensure dataset cellkey present
  const key = getCellKey(btn);
  btn.setAttribute('data-cellkey', key);
  return key;
}
function cycleSymbol(btn){
  // cycle through symbols array
  const cur = btn.dataset.val || '';
  let idx = symbols.indexOf(cur);
  idx = (idx + 1) % symbols.length;
  btn.dataset.val = symbols[idx];
  btn.textContent = symbols[idx] || '';
  // keep selection visual
}

/* ---------- Palette actions ---------- */
qAll('.symBtn').forEach(b=>{
  b.addEventListener('click', ()=> {
    const sym = b.dataset.sym;
    // if some cells selected => apply to them; else apply to last clicked cell (not selected)
    if(selectedCells.size > 0){
      selectedCells.forEach(key=>{
        const el = document.querySelector(`[data-cellkey="${key}"]`);
        if(el){
          el.dataset.val = sym;
          el.textContent = sym || '';
          el.classList.remove('sel');
        }
      });
      // clear selection after apply
      selectedCells = new Set();
    } else {
      // try to find last focused cell
      const last = document.activeElement;
      if(last && last.classList && last.classList.contains('cellBtn')){
        last.dataset.val = sym;
        last.textContent = sym || '';
      } else {
        // nothing selected: apply to all cells? no. show hint
        alert('Chọn 1 hoặc nhiều ô (click) rồi bấm ký hiệu để gán. Hoặc double-click ô để đổi nhanh.');
      }
    }
  });
});

/* ---------- Utility to read grid into array ---------- */
function readGridFrom(containerId){
  const container = q(containerId);
  if(!container) return null;
  const header = container.children[0];
  if(!header) return null;
  const cols = header.children.length;
  const rowDivs = Array.from(container.children).slice(1); // each rowDiv
  const rows = rowDivs.length;
  const cells = Array.from({length:rows}, ()=> Array(cols).fill(''));
  for(let r=0;r<rows;r++){
    const rowDiv = rowDivs[r];
    for(let c=0;c<cols;c++){
      const btn = rowDiv.children[c];
      if(!btn) continue;
      // ensure data-cellkey set
      const key = getCellKey(btn);
      btn.setAttribute('data-cellkey', key);
      const val = (btn.dataset.val || '').trim();
      cells[r][c] = val;
    }
  }
  return {cols, rows, cells};
}

/* ---------- Fill example patterns ---------- */
function fillExample(containerId, patternTop, patternBottom){
  const grid = readGridFrom(containerId);
  if(!grid) return;
  const {cols, rows, cells} = grid;
  // if rows==1: fill only first; if rows>=2: use patternTop as row0, patternBottom row1; else fill blanks
  const rowDivs = q(containerId).querySelectorAll('.row');
  for(let r=0;r<rows;r++){
    for(let c=0;c<cols;c++){
      const btn = rowDivs[r].children[c];
      let val = '';
      if(rows === 1){
        val = patternTop[c % patternTop.length] || '';
      } else {
        if(r === 0) val = patternTop[c % patternTop.length] || '';
        else val = patternBottom[c % patternBottom.length] || patternTop[c % patternTop.length] || '';
      }
      btn.dataset.val = val;
      btn.textContent = val;
    }
  }
}

/* ---------- Counting logic ---------- */
function countFromGrid(gridData, totalCams){
  // gridData: {cols, rows, cells matrix}
  // Represent columns 0..C-1. Each column c has counts across rows.
  const C = gridData.cols;
  const R = gridData.rows;
  const T = totalCams;
  const repeats = Math.floor(T / C);
  const rem = T % C;
  // per column counts
  const perCol = [];
  for(let c=0;c<C;c++){
    const map = {};
    for(let r=0;r<R;r++){
      const sym = gridData.cells[r][c] || '';
      if(sym === '') continue;
      map[sym] = (map[sym] || 0) + 1;
    }
    perCol.push(map);
  }
  // total scaled counts
  const totals = {};
  for(let c=0;c<C;c++){
    const colMap = perCol[c];
    for(const k in colMap){
      totals[k] = (totals[k] || 0) + colMap[k] * repeats;
    }
    if(c < rem){
      for(const k in colMap){
        totals[k] = (totals[k] || 0) + colMap[k];
      }
    }
  }
  return {perCol, totals, repeats, rem};
}

/* ---------- UI events ---------- */
q('#genOld').addEventListener('click', ()=>{
  const cols = parseInt(q('#colsOld').value) || 1;
  const rows = parseInt(q('#rowsOld').value) || 1;
  createGrid('#gridOldWrap', cols, rows, 'old');
});
q('#genNew').addEventListener('click', ()=>{
  const cols = parseInt(q('#colsNew').value) || 1;
  const rows = parseInt(q('#rowsNew').value) || 1;
  createGrid('#gridNewWrap', cols, rows, 'new');
});
q('#clearOld').addEventListener('click', ()=> q('#gridOldWrap').innerHTML = '');
q('#clearNew').addEventListener('click', ()=> q('#gridNewWrap').innerHTML = '');
q('#fillOld').addEventListener('click', ()=> {
  // example pattern similar to convo: top H1: - v - v ; H2: u - u -
  const gridEl = q('#gridOldWrap');
  if(!gridEl.children.length){ alert('Tạo lưới trước.'); return; }
  fillExample('#gridOldWrap', ['-','v','-','v'], ['凵','-','凵','-']);
});
q('#fillNew').addEventListener('click', ()=> {
  const gridEl = q('#gridNewWrap');
  if(!gridEl.children.length){ alert('Tạo lưới trước.'); return; }
  fillExample('#gridNewWrap', ['v','凵','-','-','v','凵'], ['凵','-','凵','-','凵','-']);
});

/* Compute & show results */
q('#compute').addEventListener('click', ()=>{
  const total = parseInt(q('#totalCams').value) || 0;
  if(total <= 0){ alert('Nhập tổng CAM (>0).'); return; }
  const oldGrid = readGridFrom('#gridOldWrap');
  const newGrid = readGridFrom('#gridNewWrap');
  if(!oldGrid || !newGrid){ alert('Cần tạo cả ĐƠN CŨ và ĐƠN MỚI.'); return; }
  // build gridData with cells matrix filled
  const oldContainer = q('#gridOldWrap');
  const newContainer = q('#gridNewWrap');
  const oldRows = Array.from(oldContainer.querySelectorAll('.row')).map(row=>{
    return Array.from(row.children).map(btn => btn.dataset.val || '');
  });
  const newRows = Array.from(newContainer.querySelectorAll('.row')).map(row=>{
    return Array.from(row.children).map(btn => btn.dataset.val || '');
  });
  const oldData = {cols: oldGrid.cols, rows: oldGrid.rows, cells: oldRows};
  const newData = {cols: newGrid.cols, rows: newGrid.rows, cells: newRows};

  const resOld = countFromGrid(oldData, total);
  const resNew = countFromGrid(newData, total);

  // union of symbols
  const keys = new Set([...Object.keys(resOld.totals), ...Object.keys(resNew.totals)]);
  const sortedKeys = Array.from(keys).sort((a,b)=>{
    const pref = ['-','^','凵'];
    const ia = pref.indexOf(a), ib = pref.indexOf(b);
    if(ia>=0 || ib>=0) {
      if(ia>=0 && ib>=0) return ia-ib;
      return ia>=0? -1 : 1;
    }
    return (resNew.totals[b]||0) - (resNew.totals[a]||0) || a.localeCompare(b);
  });

  // show results
  let html = '<div class="card"><h3>Kết quả</h3>';
  html += `<div class="hint">Tổng CAM = ${total}. Đơn cũ chu kỳ ${oldData.cols} cột × ${oldData.rows} hàng → rep=${resOld.repeats}, rem=${resOld.rem}. Đơn mới chu kỳ ${newData.cols} cột × ${newData.rows} hàng → rep=${resNew.repeats}, rem=${resNew.rem}.</div>`;
  html += '<table><thead><tr><th>Ký hiệu</th><th>Đơn cũ</th><th>Đơn mới</th><th>Bù trừ (mới−cũ)</th></tr></thead><tbody>';
  const outRows = [];
  sortedKeys.forEach(k=>{
    const oldv = resOld.totals[k]||0;
    const newv = resNew.totals[k]||0;
    const d = newv - oldv;
    html += `<tr><td>${k||'(blank)'}</td><td>${oldv}</td><td>${newv}</td><td class="${d>0?'pos':(d<0?'neg':'')}">${d>0?'+':''}${d}</td></tr>`;
    outRows.push({symbol:k, old:oldv, new:newv, delta:d});
  });
  html += '</tbody></table>';
  html += `<div style="margin-top:8px"><button id="exportResultCsv" class="ghost">Tải CSV kết quả</button></div>`;
  html += '</div>';
  q('#resultArea').innerHTML = html;
  // attach export handler
  q('#exportResultCsv').addEventListener('click', ()=>{
    let csv = 'Ký hiệu,Đơn cũ,Đơn mới,Bù trừ\\n';
    outRows.forEach(r=> csv += `"${r.symbol}",${r.old},${r.new},${r.delta}\\n`);
    const blob = new Blob([csv], {type:'text/csv;charset=utf-8;'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a'); a.href = url; a.download = 'kq_butru.csv'; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
  });
});

/* CSV export of current grids raw (optional) */
q('#exportCsv').addEventListener('click', ()=>{
  const oldGrid = readGridFrom('#gridOldWrap');
  const newGrid = readGridFrom('#gridNewWrap');
  if(!oldGrid || !newGrid){ alert('Cần tạo cả ĐƠN CŨ và ĐƠN MỚI.'); return; }
  // Build CSV with per-cycle cells (rows)
  function gridToCSV(grid, containerId, title){
    let s = `${title}\\n`;
    for(let r=0;r<grid.rows;r++){
      const row = Array.from(q(containerId).querySelectorAll('.row'))[r];
      const cells = Array.from(row.children).map(b=>`"${(b.dataset.val||'')}"`);
      s += cells.join(',') + '\\n';
    }
    return s;
  }
  const csv = gridToCSV(oldGrid, '#gridOldWrap', 'OLD') + '\\n' + gridToCSV(newGrid, '#gridNewWrap', 'NEW');
  const blob = new Blob([csv], {type:'text/csv;charset=utf-8;'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = 'grid_raw.csv'; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
});

/* Reset all */
q('#resetAll').addEventListener('click', ()=>{
  if(!confirm('Reset toàn bộ?')) return;
  q('#gridOldWrap').innerHTML = '';
  q('#gridNewWrap').innerHTML = '';
  q('#resultArea').innerHTML = '';
  q('#colsOld').value = 4; q('#rowsOld').value = 2; q('#colsNew').value = 6; q('#rowsNew').value = 2; q('#totalCams').value = 84;
});

/* Initialize default grids */
createGrid('#gridOldWrap', 4, 2, 'old');
createGrid('#gridNewWrap', 6, 2, 'new');

</script>
</body>
</html>